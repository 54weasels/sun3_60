Name        sun3_60_MMU ;
PartNo      00 ;
Date        2025-06-01 ;
Revision    01 ;
Designer    RomainDolbeau ;
Company     none ;
Assembly    Sun 3/60 ;
Location    Uxxx ;
Device      F1504ISPTQFP100;

/* this consolidates the three MMU PAL of the 3/60 (U230, U231, U232)
   plus the FCDECODE PAL (U102) into a single CPLD.
   This has not been tested (except for compiling with Wincupl),
   and is currently for documentation of the Sun 3/60 MMU and space/address map.
   
   U230	is 1570-01
   U231	is 1571-01
   U232	is 1574-01
   U102	is 1567-01

*/

/* Enable JTAG interface with internal 10K pullups on TDI and TMS */
PROPERTY ATMEL { JTAG = ON } ;
PROPERTY ATMEL { TDI_PULLUP = ON } ;
PROPERTY ATMEL { TMS_PULLUP = ON } ;

/* Consider pin assignments to be immutable; don't try to rearrange the design
if it does not fit with the given pin assignments */
/*
PROPERTY ATMEL { PREASSIGN = KEEP } ;
*/

/*
Pin#     Function
     1     NC
     2     NC
     3     VCC
     4     IO/TDI
     5     NC
     6     IO
     7     NC
     8     IO
     9     IO
    10     IO
    11     GND
    12     IO/PD
    13     IO
    14     IO
    15     IO/TMS
    16     IO
    17     IO
    18     VCC
    19     IO
    20     IO
    21     IO
    22     NC
    23     IO
    24     NC
    25     IO
    26     GND
    27     NC
    28     NC
    29     IO
    30     IO
    31     IO
    32     IO
    33     IO
    34     VCC
    35     IO
    36     IO
    37     IO
    38     GND
    39     VCC
    40     IO
    41     IO
    42     IO/PD
    43     GND
    44     IO
    45     IO
    46     IO
    47     IO
    48     IO
    49     NC
    50     NC
    51     VCC
    52     IO
    53     NC
    54     IO
    55     NC
    56     IO
    57     IO
    58     IO
    59     GND
    60     IO
    61     IO
    62     IO/TCK
    63     IO
    64     IO
    65     IO
    66     VCC
    67     IO
    68     IO
    69     IO
    70     NC
    71     IO
    72     NC
    73     IO/TDO
    74     GND
    75     IO
    76     IO
    77     NC
    78     NC
    79     IO
    80     IO
    81     IO
    82     VCC
    83     IO
    84     IO
    85     IO/CLK
    86     GND
    87     IN/CLK
    88     IN/OE
    89     IN/CLR
    90     IN/CLK/OE
    91     VCC
    92     IO
    93     IO
    94     IO
    95     GND
    96     IO
    97     IO
    98     IO
    99     IO
   100     IO
*/

/* INPUTS */
/* 1574-01 */
PIN 6 = !IN_WE_PMAP0; /* also output of 1571-01, could be bypassed */
PIN 8 = MMU_V;
PIN 9 = MMU_W;
PIN 10 = MMU_S;
PIN 13 = !EN_DEV; /* output from 1567-01, could be bypassed  */
PIN 14 = !WRITE;
PIN 16 = FC2;
PIN 17 = !C_S5;
PIN 19 = !C_S7X;
/* 1571-01 */
PIN 20 = A0;
PIN 21 = A1;
PIN 23 = A28;
PIN 25 = A29;
PIN 29 = A30;
PIN 30 = !EN_CTL; /* output from 1567-01, could be bypassed */
/* !WRITE,  */
PIN 31 = !C_S3;
/* !C_S5, !C_S7X */
/* 1570-01 */
/* A0, A1, A28, A29, A30, !EN_CTL, !WRITE, !C_S3, !C_S5, !C_S7X */

/* OUTPUTS */
/* 1574-01 */
PIN 32 = !BERR_P;
PIN 33 = ACCESSX;
PIN 35 = !WE_STAT;
PIN 36 = !BERR_V;
/* 1571-01 */
PIN 37 = !EN_PMAP0;
PIN 40 = !WE_PMAP0; /* also input to 1574-01 */
PIN 41 = !EN_PMAP2;
PIN 44 = !WE_PMAP2;
PIN 45 = !EN_PMAP3;
PIN 46 = !WE_PMAP3;
PIN 47 = !WE_SMAP;
PIN 48 = !EN_SMAP;
/* 1570-01 */
PIN 52 = DSACK0n;
PIN 54 = !WR_DIAG;
PIN 56 = !RD_BERR;
PIN 57 = !RD_ID;
PIN 58 = !RD_SYSEN;
PIN 60 = !WR_SYSEN;
PIN 61 = !RD_CX;
PIN 63 = !WR_CX;

/* INOUTS */
/* 1574-01 */
PIN 64 = !DISACC;
PIN 65 = MODIFYX;
PIN 67 = TYPE0X;
PIN 68 = TYPE1X;


/* INPUTS */
/* 1567-01 */
/* A28, A29, A30 */
PIN 69 = A31;
PIN 71 = FC0;
PIN 75 = FC1;
/* FC2 */
PIN 76 = !R_ACK;
PIN 79 = AS;
/* PIN 80 = TEST1; */
PIN 81 = !EN_BOOT;
/* output */
PIN 83 = !EN_UART;
PIN 84 = !DIS_RAS;
PIN 92 = !OUT_EN_CTL;
PIN 93 = !OUT_EN_DEV;
PIN 94 = !OE_BOOT;

/*
PIN 96 = ;
PIN 97 = ;
PIN 98 = ;
PIN 99 = ;
PIN 100 = ;
*/


/* Note that DSACK0n and YYY are active-low signals but we do NOT declare them
inverted here, as the ATF1502 fitter seems to ignore output enables on pins that
are declared inverted */

/* Signals that are IN from one PAL and OUT from another have been kept separate, so will need a loopback on the PCB.
   In theory this is not needed (you can reuse the output signal directly as an internal input), but using a bypass would probably change the timings more than just moving from GAL to CPLD... */

/*
RESERVED
PIN 4   = TDI ;
PIN 15  = TMS ;
PIN 62  = TCK ;
PIN 73  = TDO ;
*/



/* EN_CTL is generated by U102 (1567-01), and check for half the control space with A31=0 during a cycle(FC=0x3, A31=0, /AS active)
   So the address control below does not need to check for !A31
   From the architecture manual v2 (section 4.1, with extra details later):
   IDPROM is in         A[28..31] = 0x0, byte-sized, RO, 32 bytes
   SYSTEM ENABLE is in  A[28..31] = 0x4, byte-sized, RW,  1 byte
   USER DVMA is in      A[28..31] = 0x5, byte-sized, RW,  1 byte
   BUS ERROR is in      A[28..31] = 0x6, byte-sized, RO,  1 byte
   DIAGNOSTIC is in     A[28..31] = 0x7, byte-sized, WO,  1 byte (control leds)

   The same space also has the MMU registers (same source):
   CONTEXT is in        A[28..31] = 0x3, byte-sized, RW,  1 byte
   SEGMENT MAP is in    A[28..31] = 0x2, byte-sized, RW,  16384 entries, addressed by {CX[0..2], A[17..27]}
   PAGE MAP    is in    A[28..31] = 0x1, long-sized, RW,   4096 entries, addressed by {CX[0..2], A[??..27]}

   A[28..31] 0x8 to 0xA are cache operations, the 3/60 has no external cache.
             0xB is for "block copy", presumably not implemented
	     0xC to 0xE are unused architecturally
	     0xF is the UART bypass (done in 1567-01)
   It seems the USER DVMA register is not implemented on the 3/60, either.

   1570-01 generates the RD/WR signals for IDPROM, SYSTEM ENABLE, BUS ERROR, DIAGNOSTIC and CONTEXT.
           it also handle DSACK0 when EN_CTL is active.

   1571-01 generates the RD/WR signals for SEGMENT MAP, and PAGE MAP (three sets)
   	   PMAP0 controls the 8-bits of status (MMU.{X,S,W,V}, MODIFY, ACCESS, TYPE0, TYPE1)
	   PMAP2 controls the 8-bits of address from PA21 to PA28
	   PMAP3 controls the 8-bits of address from PA13 to PA20
	   From the usage of A[0..1], it seems those must always use byte load/store, and only the high-order
	    8 bites (via PMAP0) and low-order 16bits (via PMAP2 and PMAP3) are used. Which means the 3/60 only
	    use 11bits of physical page number (S3AMv2 section 4.6.8), or that it doesn't fully comply with
	    this document? (using 16 bits with an extra 3 being implicitly 0 maybe?) => it's 16 bits plus 3
	     read as zero, see the NetBSD kernel code
<https://github.com/NetBSD/src/blob/8e6d7defa0dca699514fe6e292d5c2918d8a4b54/sys/arch/sun3/sun3/pmap.c#L151-L155>
             I suspect it means we could add back the three bits fairly easily if we wanted an improved 3/60
	     with more usable memory (the schematics for the 3/160 has the extra three bits visible)

   1574-01 generates some of the status bits? And handles permissions
*/

/* 1574-01 */
WE_STAT	= (IN_WE_PMAP0 # (EN_DEV & !DISACC & C_S5 & !C_S7X));
/* common enable signal for all 4 bits */
mmu1574_oe = (EN_DEV & !DISACC & C_S5 & !C_S7X);
TYPE1X = TYPE1X;
TYPE1X.oe = mmu1574_oe;
TYPE0X = TYPE0X;
TYPE0X.oe = mmu1574_oe;
ACCESSX	=  'b'1;
ACCESSX.oe = mmu1574_oe;
MODIFYX	= (WRITE & !MODIFYX);
MODIFYX.oe = mmu1574_oe;
DISACC	= ((!MMU_V                  & EN_DEV) #                 /* access not valid [also BERR_V] */
           ( MMU_V & MMU_S          & EN_DEV & !FC2) #          /* supervisor-only access but not supervisor request (FC2==1 is supervisor) [also BERR_P]*/
	   ( MMU_V         & !MMU_W & EN_DEV         & WRITE)); /* read-only access but attempting to write [also BERR_P] */
BERR_V	=  (!MMU_V                  & EN_DEV);
BERR_P	= (( MMU_V & MMU_S          & EN_DEV & !FC2) #
	   ( MMU_V         & !MMU_W & EN_DEV         & WRITE));

/* 1571-01 */
WE_SMAP	 = (            !A28 &  A29 & !A30 & EN_CTL & WRITE & C_S3         & !C_S7X);
EN_SMAP	 = (            !A28 &  A29 & !A30 & EN_CTL                & C_S5);
WE_PMAP3 = ( A1 &  A0 &  A28 & !A29 & !A30 & EN_CTL & WRITE & C_S3         & !C_S7X);
EN_PMAP3 = ( A1 &  A0 &  A28 & !A29 & !A30 & EN_CTL                & C_S5);
WE_PMAP2 = ( A1 & !A0 &  A28 & !A29 & !A30 & EN_CTL & WRITE & C_S3         & !C_S7X);
EN_PMAP2 = ( A1 & !A0 &  A28 & !A29 & !A30 & EN_CTL                & C_S5);
WE_PMAP0 = (!A1 & !A0 &  A28 & !A29 & !A30 & EN_CTL & WRITE & C_S3         & !C_S7X);
EN_PMAP0 = (!A1 & !A0 &  A28 & !A29 & !A30 & EN_CTL                & C_S5);

/* 1570-01 */
WR_CX	 = (!A1 & !A0 &  A28 &  A29 & !A30 & EN_CTL &  WRITE & C_S3        & !C_S7X);
RD_CX	 = (!A1 & !A0 &  A28 &  A29 & !A30 & EN_CTL & !WRITE & C_S3);
WR_SYSEN = (!A1 & !A0 & !A28 & !A29 &  A30 & EN_CTL &  WRITE & C_S3        & !C_S7X);
RD_SYSEN = (!A1 & !A0 & !A28 & !A29 &  A30 & EN_CTL & !WRITE & C_S3);
RD_ID	 = (            !A28 & !A29 & !A30 & EN_CTL & !WRITE & C_S3);
RD_BERR	 = (!A1 & !A0 & !A28 &  A29 &  A30 & EN_CTL & !WRITE & C_S3);
WR_DIAG	 = (!A1 & !A0 &  A28 &  A29 &  A30 & EN_CTL &  WRITE & C_S3        & !C_S7X);

DSACK0n = 'b'0;
DSACK0_oe =(EN_CTL & C_S5 & C_S7X);



/* 1567-01 */
/*
FC	Space...
0x0	Reserved
0x1	Device Space (User Data)
0x2	Device Space (User Program)
0x3	Control Space
0x4	Reserved
0x5	Device Space (Supervisor Data)
0x6	Device Space (Supervisor Program)
0x7	CPU Space

OE_BOOT  enabled for Device Space (Supervisor Program) during EN_BOOT (in a cycle)
EN_CTL   enabled for Control Space with !A31 (in a cycle)
DIS_RAS  enabled for CPU Space
EN_UART  enabled for Control Space and A[28..31] == 0xF, it's a the UART bypass (see above)
EN_DEV   enabled as long as R_ACK is inactive, for conditions:
	 A[28..31] == 0x0 in Device Space (User Program)
	 A[28..31] == 0x0 in Davice Space (* Data)
	 A[28..31] == 0xF in Device Space (User Program)
	 A[28..31] == 0xF in Davice Space (* Data)
	 A[28..31] == 0x0 in Device Space (* Program) without EN_BOOT
	 A[28..31] == 0xF in Davice Space (* Program) without EN_BOOT
	 So both 0x0 and 0xF are always accessible for Data and User Program, but only available to Supervisor Program when !EN_BOOT.
	 0x0 is a 256 MiB range, where main memory lives (for Type 0 devices, which means main memory)
	 0xF is a 256 MiB range, where framebuffer memory lives (for Type 0 devices)
	 Type 1 device ssems to all lives in the lower part of their space.
	 Type 2/3 (VME) aren't supported on the 3/60.
	 Type 0/1/2/3 is determined by the MMU mapping, via 2 bits in the PAGE MAP
*/

OE_BOOT	   = (                             !FC0 &  FC1 &  FC2 &  EN_BOOT           & AS);
OUT_EN_DEV = ((!A29 & !A28 & !A30 & !A31 & !FC0 &  FC1 & !FC2            & !R_ACK) #
	      (!A29 & !A28 & !A30 & !A31 &  FC0 & !FC1                   & !R_ACK) #
	      ( A29 &  A28 &  A30 &  A31 & !FC0 &  FC1 & !FC2            & !R_ACK) #
	      ( A29 &  A28 &  A30 &  A31 &  FC0 & !FC1                   & !R_ACK) #
	      (!A29 & !A28 & !A30 & !A31 & !FC0 &  FC1        & !EN_BOOT & !R_ACK) #
	      ( A29 &  A28 &  A30 &  A31 & !FC0 &  FC1        & !EN_BOOT & !R_ACK));
OUT_EN_CTL = (                      !A31 &  FC0 &  FC1 & !FC2                      & AS);
DIS_RAS	   = (                              FC0 &  FC1 &  FC2);
EN_UART	   = (  A29 &  A28 &  A30 &  A31 &  FC0 &  FC1 & !FC2                      & AS);

/* not needed, might mess with negative-logic... */
/*
OE_BOOT.oe =    !TEST1;
OUT_EN_DEV.oe = !TEST1;
OUT_EN_CTL.oe = !TEST1;
DIS_RAS.oe =    !TEST1;
EN_UART.oe =    !TEST1;
*/
